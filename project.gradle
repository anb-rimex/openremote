// Common configuration applied to all projects
import static org.apache.tools.ant.taskdefs.condition.Os.*

// Build plugins
buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "com.moowork.gradle:gradle-node-plugin:1.2.0"
    }
}

// Default repositories for dependency resolution
repositories {
    mavenCentral()
    jcenter()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
    maven {
        url "http://m2repo.openremote.com/content/groups/public/"
    }
    maven {
        url "http://4thline.org/m2"
    }
}

// Eclipse needs help
apply plugin: "eclipse"

// Intellij needs help
apply plugin: 'idea'
// Use the same output directories in IDE as in gradle
idea {
    module {
        outputDir file('build/classes/main')
        testOutputDir file('build/classes/test')
        excludeDirs += file(".node")
    }
}
if(project.convention.findPlugin(JavaPluginConvention)) {
    // Change the output directory for the main and test source sets back to the old path
    sourceSets.main.output.classesDirs = new File(buildDir, "classes/main")
    sourceSets.test.output.classesDirs = new File(buildDir, "classes/test")
}

// Configure versions in gradle.properties (putting a gradle.properties file
// in a subproject only overrides root properties of same name for the actual
// subproject, not for its children!)
version = hasProperty("openremoteVersion") ? openremoteVersion : projectVersion

// Add NodeJS plugin configuration and tasks
apply plugin: com.moowork.gradle.node.NodePlugin
node {
    download = true
    version = "8.9.0"
    workDir = file("${rootDir}/.node")
}
ext.nodeDir = {
    def osName = com.moowork.gradle.node.util.PlatformHelper.INSTANCE.getOsName()
    def osArch = com.moowork.gradle.node.util.PlatformHelper.INSTANCE.getOsArch()
    def version = node.version
    node.workDir.absolutePath + File.separator + "node-v${version}-${osName}-${osArch}"
}
ext.nodeModuleDir = {
    isFamily(FAMILY_WINDOWS) ? "${nodeDir()}/node_modules" : "${nodeDir()}/lib/node_modules"
}
ext.nodeModuleGlobal = {
    dir, mod ->
        file("${nodeModuleDir()}/${dir}/bin/${mod}")
}
ext.nodeModuleLocal = {
    dir, mod ->
        file("${projectDir}/node_modules/${dir}/bin/${mod}")
}

// Add bower tasks
task bowerInstall(type: NpmTask) {
    dependsOn nodeSetup
    args = ['install', '-g', 'bower']
    outputs.upToDateWhen {
        nodeModuleGlobal('bower', 'bower').exists()
    }
}
task bowerUpdate(type: NodeTask) {
    dependsOn bowerInstall
    script = nodeModuleGlobal('bower', 'bower')
    args = ['update']
    inputs.file("${project.projectDir}/bower.json")
    outputs.dir("${project.projectDir}/bower_components")
}
task bowerPrune(type: NodeTask) {
    dependsOn bowerInstall
    script = nodeModuleGlobal('bower', 'bower')
    args = ['prune']
    inputs.file("${project.projectDir}/bower.json")
    outputs.dir("${project.projectDir}/bower_components")
}

// TODO Test this... Add polymer tasks, we really only want to compile ES6 to ES5, maybe some minification!
/*
task polymerInstall(type: NpmTask) {
    dependsOn nodeSetup
    args = ['install', '-g', 'polymer-cli']
    outputs.upToDateWhen {
        nodeModuleGlobal('polymer-cli', 'polymer-cli').exists()
    }
}
task polymerServe(type: NodeTask) {
    dependsOn polymerInstall
    script = nodeModuleGlobal('polymer-cli', 'polymer-cli')
    args = ['serve']
}
*/

// Configure Java build
plugins.withType(JavaPlugin).whenPluginAdded {

    // Use Java 8
    tasks.withType(JavaCompile) {
        sourceCompatibility = "1.8"
        targetCompatibility = "1.8"
        def warnLogFile = file("$buildDir/${name}Warnings.log")
        logging.addStandardErrorListener(new StandardOutputListener() {
            void onOutput(CharSequence output) {
                warnLogFile << output
            }
        })
        options.compilerArgs += ["-Xlint:unchecked", "-Xlint:deprecation"]
        options.encoding = 'UTF-8'
    }

    // JAR/ZIP base name is the fully qualified subproject name
    archivesBaseName = "${rootProject.name}${path.replaceAll(":", "-")}"
}

// Helper functions for project/task resolution when the main 
// repo is checked out as a git submodule and therefore a subproject
def resolvePath(String path) {
    findProject(":openremote") != null ? ":openremote" + path : path
}

def resolveProject(String path) {
    project(resolvePath(path))
}

def resolveTask(String path) {
    tasks.getByPath(resolvePath(path))
}

ext {
    resolvePath = this.&resolvePath
    resolveProject = this.&resolveProject
    resolveTask = this.&resolveTask
}